// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ==========================================
// 1. USER MANAGEMENT (Roles for Maker-Checker)
// ==========================================
model User {
  id       Int      @id @default(autoincrement())
  username String   @unique
  password String
  name     String
  role     String   @default("MAKER") // MAKER, CHECKER, ADMIN
  createdAt DateTime @default(now())

  // Relations - Updated to reference specific voucher types
  createdSales    SalesVoucher[]    @relation("SalesCreatedBy")
  verifiedSales   SalesVoucher[]    @relation("SalesVerifiedBy")
  
  createdPurchase PurchaseVoucher[] @relation("PurchaseCreatedBy")
  verifiedPurchase PurchaseVoucher[] @relation("PurchaseVerifiedBy")
  
  createdPayment  PaymentVoucher[]  @relation("PaymentCreatedBy")
  verifiedPayment PaymentVoucher[]  @relation("PaymentVerifiedBy")
  
  createdReceipt  ReceiptVoucher[]  @relation("ReceiptCreatedBy")
  verifiedReceipt ReceiptVoucher[]  @relation("ReceiptVerifiedBy")
  
  createdContra   ContraVoucher[]   @relation("ContraCreatedBy")
  verifiedContra  ContraVoucher[]   @relation("ContraVerifiedBy")
  
  createdJournal  JournalVoucher[]  @relation("JournalCreatedBy")
  verifiedJournal JournalVoucher[]  @relation("JournalVerifiedBy")
  
  createdStockJournals StockJournal[] @relation("StockJournalCreatedBy")
  verifiedStockJournals StockJournal[] @relation("StockJournalVerifiedBy")
  
  createdBoms BOM[] @relation("BOMMaker")
}

// ==========================================
// 2. COMPANY DATA
// ==========================================
model Company {
  id               Int      @id @default(autoincrement())
  name             String
  address          String?  @db.Text
  state            String?
  pincode          String?
  email            String?
  gstin            String?
  
  // Settings
  currencySymbol   String   @default("₹")
  financialYearFrom DateTime
  booksBeginFrom    DateTime

  // Relations
  groups           Group[]
  ledgers          Ledger[]
  units            Unit[]
  stockGroups      StockGroup[]
  stockItems       StockItem[]
  sequences        VoucherSequence[]
  boms             BOM[]
  
  // Separate Voucher Relations
  salesVouchers    SalesVoucher[]
  purchaseVouchers PurchaseVoucher[]
  paymentVouchers  PaymentVoucher[]
  receiptVouchers  ReceiptVoucher[]
  contraVouchers   ContraVoucher[]
  journalVouchers  JournalVoucher[]
  stockJournals    StockJournal[]
  
  createdAt        DateTime @default(now())
}

// ==========================================
// 3. AUTO-NUMBERING
// ==========================================
model VoucherSequence {
  id          Int     @id @default(autoincrement())
  companyId   Int
  company     Company @relation(fields: [companyId], references: [id])
  voucherType String  // PAYMENT, RECEIPT, CONTRA, JOURNAL, STOCK_JOURNAL
  lastNo      Int     @default(0)

  @@unique([companyId, voucherType])
}

// ==========================================
// 4. ACCOUNTING MASTERS (Groups & Ledgers)
// ==========================================
model Group {
  id        Int     @id @default(autoincrement())
  name      String
  nature    String? // ASSET, LIABILITY, INCOME, EXPENSE
  
  companyId Int
  company   Company @relation(fields: [companyId], references: [id])
  
  ledgers   Ledger[]
  
  // Self-Relation (Groups inside Groups)
  parentId  Int?
  parent    Group?  @relation("GroupHierarchy", fields: [parentId], references: [id])
  children  Group[] @relation("GroupHierarchy")

  @@unique([name, companyId])
}

model Ledger {
  id              Int     @id @default(autoincrement())
  name            String
  address         String? @db.Text
  openingBalance  Float   @default(0.0)
  
  groupId         Int?
  group           Group?  @relation(fields: [groupId], references: [id])
  
  companyId       Int
  company         Company @relation(fields: [companyId], references: [id])
  
  // Relations to Voucher Entries (One for each type)
  salesEntries    SalesLedgerEntry[]
  purchaseEntries PurchaseLedgerEntry[]
  paymentEntries  PaymentLedgerEntry[]
  receiptEntries  ReceiptLedgerEntry[]
  contraEntries   ContraLedgerEntry[]
  journalEntries  JournalLedgerEntry[]

  // Also referenced as Party Ledger in transactions
  salesParties    SalesVoucher[]    @relation("SalesPartyLedger")
  purchaseParties PurchaseVoucher[] @relation("PurchasePartyLedger")

  // Tally Specifics
  tallyName       String?
  state           String?
  gstin           String?

  @@unique([name, companyId])
}

// ==========================================
// 5. INVENTORY MASTERS
// ==========================================
model Unit {
  id        Int       @id @default(autoincrement())
  name      String
  symbol    String
  companyId Int
  company   Company   @relation(fields: [companyId], references: [id])
  items     StockItem[]
  
  @@unique([symbol, companyId])
}

model StockGroup {
  id        Int       @id @default(autoincrement())
  name      String
  companyId Int
  company   Company   @relation(fields: [companyId], references: [id])
  items     StockItem[]
  
  parentId  Int?
  parent    StockGroup? @relation("StockHierarchy", fields: [parentId], references: [id])
  children  StockGroup[] @relation("StockHierarchy")
  
  @@unique([name, companyId])
}

model StockItem {
  id             Int      @id @default(autoincrement())
  name           String
  partNumber     String?
  
  // Balance Fields
  openingQty     Float    @default(0)
  openingValue   Float    @default(0)
  quantity       Float    @default(0) // Current Stock level
  
  // Alerts
  minStock       Float    @default(0) 

  groupId        Int?
  group          StockGroup? @relation(fields: [groupId], references: [id])
  
  unitId         Int?
  unit           Unit?       @relation(fields: [unitId], references: [id])
  
  companyId      Int
  company        Company     @relation(fields: [companyId], references: [id])
  
  gstRate        Float       @default(0) 

  // Relations to Voucher Inventory Entries
  salesItems     SalesItemEntry[]
  purchaseItems  PurchaseItemEntry[]
  
  journalEntries StockJournalEntry[] 

  // BOM Relations
  producedBy     BOM[]       @relation("FinishedGood")
  usedInBoms     BOMItem[]   @relation("BOMComponent")
  
  @@unique([name, companyId])
}

model BOM {
  id             Int       @id @default(autoincrement())
  name           String    
  
  finishedGoodId Int
  finishedGood   StockItem @relation("FinishedGood", fields: [finishedGoodId], references: [id])
  targetQty      Float     @default(1.0) 
  
  components     BOMItem[]

  companyId      Int
  company        Company   @relation(fields: [companyId], references: [id])

  createdById    Int
  createdBy      User      @relation("BOMMaker", fields: [createdById], references: [id])
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

model BOMItem {
  id          Int       @id @default(autoincrement())
  bomId       Int
  bom         BOM       @relation(fields: [bomId], references: [id], onDelete: Cascade)
  
  stockItemId Int
  stockItem   StockItem @relation("BOMComponent", fields: [stockItemId], references: [id])
  quantity    Float    
}

// ==========================================
// 6. SALES VOUCHER (Manual No + Inventory)
// ==========================================
model SalesVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])
  
  // MANUAL NUMBERING (String)
  voucherNo       String   
  transactionCode String?  @unique
  
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float

  // Specific Fields
  partyName       String?
  partyLedgerId   Int?
  partyLedger     Ledger?  @relation("SalesPartyLedger", fields: [partyLedgerId], references: [id])
  gstin           String?
  placeOfSupply   String?
  
  // Relations
  ledgerEntries   SalesLedgerEntry[]
  inventoryEntries SalesItemEntry[]

  // Approval Workflow
  status          String   @default("PENDING") // PENDING, APPROVED, REJECTED
  rejectionReason String?  @db.Text
  
  createdById     Int
  createdBy       User     @relation("SalesCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("SalesVerifiedBy", fields: [verifiedById], references: [id])
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // PREVENT DUPLICATE VOUCHER NO IN SALES
  @@unique([companyId, voucherNo])
}

model SalesLedgerEntry {
  id            Int          @id @default(autoincrement())
  salesId       Int
  salesVoucher  SalesVoucher @relation(fields: [salesId], references: [id], onDelete: Cascade)
  ledgerId      Int
  ledger        Ledger       @relation(fields: [ledgerId], references: [id])
  amount        Float        // Debit/Credit
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate      DateTime?    
}

model SalesItemEntry {
  id            Int          @id @default(autoincrement())
  salesId       Int
  salesVoucher  SalesVoucher @relation(fields: [salesId], references: [id], onDelete: Cascade)
  stockItemId   Int
  stockItem     StockItem    @relation(fields: [stockItemId], references: [id])
  quantity      Float
  rate          Float
  amount        Float
  unit          String?
}

// ==========================================
// 7. PURCHASE VOUCHER (Manual No + Inventory)
// ==========================================
model PurchaseVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])

  // MANUAL NUMBERING (String)
  voucherNo       String   
  transactionCode String?  @unique
  
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float
  
  supplierRef     String?
  partyName       String?
  partyLedgerId   Int?
  partyLedger     Ledger?  @relation("PurchasePartyLedger", fields: [partyLedgerId], references: [id])
  gstin           String?

  ledgerEntries   PurchaseLedgerEntry[]
  inventoryEntries PurchaseItemEntry[]

  status          String   @default("PENDING")
  rejectionReason String?  @db.Text

  createdById     Int
  createdBy       User     @relation("PurchaseCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("PurchaseVerifiedBy", fields: [verifiedById], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model PurchaseLedgerEntry {
  id              Int             @id @default(autoincrement())
  purchaseId      Int
  purchaseVoucher PurchaseVoucher @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  ledgerId        Int
  ledger          Ledger          @relation(fields: [ledgerId], references: [id])
  amount          Float
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate        DateTime?       
}

model PurchaseItemEntry {
  id              Int             @id @default(autoincrement())
  purchaseId      Int
  purchaseVoucher PurchaseVoucher @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  stockItemId     Int
  stockItem       StockItem       @relation(fields: [stockItemId], references: [id])
  quantity        Float
  rate            Float
  amount          Float
  unit            String?
}

// ==========================================
// 8. PAYMENT VOUCHER (Auto No, No Inventory)
// ==========================================
model PaymentVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])

  // AUTO NUMBERING (Int) - Managed by sequence logic
  voucherNo       Int      
  transactionCode String?  @unique
  
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float

  ledgerEntries   PaymentLedgerEntry[]

  status          String   @default("PENDING")
  rejectionReason String?  @db.Text

  createdById     Int
  createdBy       User     @relation("PaymentCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("PaymentVerifiedBy", fields: [verifiedById], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model PaymentLedgerEntry {
  id             Int            @id @default(autoincrement())
  paymentId      Int
  paymentVoucher PaymentVoucher @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  ledgerId       Int
  ledger         Ledger         @relation(fields: [ledgerId], references: [id])
  amount         Float
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate       DateTime?      
}

// ==========================================
// 9. RECEIPT VOUCHER (Auto No)
// ==========================================
model ReceiptVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])

  voucherNo       Int      
  transactionCode String?  @unique
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float

  ledgerEntries   ReceiptLedgerEntry[]

  status          String   @default("PENDING")
  rejectionReason String?  @db.Text

  createdById     Int
  createdBy       User     @relation("ReceiptCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("ReceiptVerifiedBy", fields: [verifiedById], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model ReceiptLedgerEntry {
  id             Int            @id @default(autoincrement())
  receiptId      Int
  receiptVoucher ReceiptVoucher @relation(fields: [receiptId], references: [id], onDelete: Cascade)
  ledgerId       Int
  ledger         Ledger         @relation(fields: [ledgerId], references: [id])
  amount         Float
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate       DateTime?      
}

// ==========================================
// 10. CONTRA VOUCHER (Auto No)
// ==========================================
model ContraVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])

  voucherNo       Int      
  transactionCode String?  @unique
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float

  ledgerEntries   ContraLedgerEntry[]

  status          String   @default("PENDING")
  rejectionReason String?  @db.Text

  createdById     Int
  createdBy       User     @relation("ContraCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("ContraVerifiedBy", fields: [verifiedById], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model ContraLedgerEntry {
  id            Int           @id @default(autoincrement())
  contraId      Int
  contraVoucher ContraVoucher @relation(fields: [contraId], references: [id], onDelete: Cascade)
  ledgerId      Int
  ledger        Ledger        @relation(fields: [ledgerId], references: [id])
  amount        Float
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate      DateTime?     
}

// ==========================================
// 11. JOURNAL VOUCHER (Auto No)
// ==========================================
model JournalVoucher {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])

  voucherNo       Int      
  transactionCode String?  @unique
  date            DateTime
  narration       String?  @db.Text
  totalAmount     Float

  ledgerEntries   JournalLedgerEntry[]

  status          String   @default("PENDING")
  rejectionReason String?  @db.Text

  createdById     Int
  createdBy       User     @relation("JournalCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("JournalVerifiedBy", fields: [verifiedById], references: [id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model JournalLedgerEntry {
  id             Int            @id @default(autoincrement())
  journalId      Int
  journalVoucher JournalVoucher @relation(fields: [journalId], references: [id], onDelete: Cascade)
  ledgerId       Int
  ledger         Ledger         @relation(fields: [ledgerId], references: [id])
  amount         Float
  
  // ✅ ADDED FOR BANK RECONCILIATION
  bankDate       DateTime?      
}

// ==========================================
// 12. STOCK JOURNAL (Manufacturing)
// ==========================================
model StockJournal {
  id              Int      @id @default(autoincrement())
  companyId       Int
  company         Company  @relation(fields: [companyId], references: [id])
  
  // Use Manual (String) or Auto (Int) - Let's stick to String "SJ-XXXX" for simplicity
  voucherNo       String   
  transactionCode String?  @unique
  
  date            DateTime
  narration       String?  @db.Text
  
  status          String   @default("PENDING")
  createdById     Int
  createdBy       User     @relation("StockJournalCreatedBy", fields: [createdById], references: [id])
  verifiedById    Int?
  verifiedBy      User?    @relation("StockJournalVerifiedBy", fields: [verifiedById], references: [id])
  
  inventoryEntries StockJournalEntry[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([companyId, voucherNo])
}

model StockJournalEntry {
  id             Int          @id @default(autoincrement())
  stockJournalId Int
  stockJournal   StockJournal @relation(fields: [stockJournalId], references: [id], onDelete: Cascade)
  
  stockItemId    Int
  stockItem      StockItem    @relation(fields: [stockItemId], references: [id])
  
  quantity       Float        // Positive = Production, Negative = Consumption
  rate           Float
  amount         Float
  
  isProduction   Boolean      // True = Source (Production), False = Destination (Consumption)
}

// ==========================================
// 13. AUDIT LOGS
// ==========================================
model AuditLog {
  id          Int      @id @default(autoincrement())
  
  // We store ID and Type loosely because they refer to different tables now
  voucherId   Int      
  voucherType String   // e.g. "SALES", "PAYMENT"
  
  userId      Int
  userName    String
  action      String   // CREATED, EDITED, VERIFIED, REJECTED
  details     String?  @db.Text
  
  createdAt   DateTime @default(now())
}


// ==========================================
// 14. FOR BACKUP & RESTORING DATA AND LOGS
// ==========================================

model DataActivityLog {
  id          String   @id @default(uuid())
  actionType  String   // "BACKUP" or "RESTORE"
  performedBy String   // User Name or Email
  fileName    String?
  timestamp   DateTime @default(now())
  status      String   // "SUCCESS" or "FAILED"
}